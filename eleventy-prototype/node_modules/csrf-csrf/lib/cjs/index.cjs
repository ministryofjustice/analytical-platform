"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.doubleCsrf = void 0;
const crypto_1 = require("crypto");
const http_errors_1 = __importDefault(require("http-errors"));
function doubleCsrf({ getSecret, cookieName = "__Host-psifi.x-csrf-token", cookieOptions: { sameSite = "lax", path = "/", secure = true, ...remainingCOokieOptions } = {}, size = 64, ignoredMethods = ["GET", "HEAD", "OPTIONS"], getTokenFromRequest = (req) => req.headers["x-csrf-token"], }) {
    const ignoredMethodsSet = new Set(ignoredMethods);
    const cookieOptions = {
        sameSite,
        path,
        secure,
        ...remainingCOokieOptions,
    };
    const invalidCsrfTokenError = (0, http_errors_1.default)(403, "invalid csrf token", {
        code: "EBADCSRFTOKEN",
    });
    const generateTokenAndHash = (req) => {
        const csrfToken = (0, crypto_1.randomBytes)(size).toString("hex");
        const secret = getSecret(req);
        const csrfTokenHash = (0, crypto_1.createHash)("sha256")
            .update(`${csrfToken}${secret}`)
            .digest("hex");
        return { csrfToken, csrfTokenHash };
    };
    const generateToken = (res, req) => {
        const { csrfToken, csrfTokenHash } = generateTokenAndHash(req);
        res.cookie(cookieName, csrfTokenHash, { ...cookieOptions, httpOnly: true });
        return csrfToken;
    };
    const getTokenHashFromRequest = remainingCOokieOptions.signed
        ? (req) => req.signedCookies[cookieName]
        : (req) => req.cookies[cookieName];
    const validateRequest = (req) => {
        const csrfTokenHash = getTokenHashFromRequest(req);
        if (typeof csrfTokenHash !== "string")
            return false;
        const csrfTokenFromRequest = getTokenFromRequest(req);
        const expectedCsrfTokenHash = (0, crypto_1.createHash)("sha256")
            .update(`${csrfTokenFromRequest}${getSecret(req)}`)
            .digest("hex");
        return csrfTokenHash === expectedCsrfTokenHash;
    };
    const doubleCsrfProtection = (req, res, next) => {
        req.csrfToken = () => generateToken(res, req);
        if (ignoredMethodsSet.has(req.method)) {
            next();
        }
        else if (validateRequest(req)) {
            next();
        }
        else {
            next(invalidCsrfTokenError);
        }
    };
    return {
        invalidCsrfTokenError,
        generateToken,
        validateRequest,
        doubleCsrfProtection,
    };
}
exports.doubleCsrf = doubleCsrf;
